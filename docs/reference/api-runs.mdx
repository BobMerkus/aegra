---
title: "Runs API"
description: "API reference for executing and managing agent runs."
---

Runs execute your agent graphs within threads. Each run takes input, executes the graph, and produces output. Runs can be streamed via SSE, awaited synchronously, or fired off in the background.

## Create run (background)

<ParamField path="POST" type="/threads/{thread_id}/runs">
  Create and start a background run. Returns the Run record immediately while execution continues asynchronously.
</ParamField>

### Path parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `thread_id` | `string` | The thread ID |

### Request body

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `assistant_id` | `string` | Yes | â€” | Assistant to execute |
| `input` | `object` | No | `null` | Graph input. Mutually exclusive with `command`. |
| `command` | `object` | No | `null` | Resume command for interrupted runs. Mutually exclusive with `input`. |
| `config` | `object` | No | `{}` | Execution config |
| `context` | `object` | No | `{}` | Execution context |
| `checkpoint` | `object` | No | `null` | Resume from a specific checkpoint |
| `stream_mode` | `string \| list[string]` | No | `null` | SSE stream modes |
| `on_disconnect` | `string` | No | `"cancel"` | Client disconnect behavior: `"cancel"` or `"continue"` |
| `multitask_strategy` | `string` | No | `null` | Concurrent run handling (see below) |
| `interrupt_before` | `string \| list[string]` | No | `null` | Nodes to pause before. Use `"*"` for all. |
| `interrupt_after` | `string \| list[string]` | No | `null` | Nodes to pause after. Use `"*"` for all. |
| `stream_subgraphs` | `boolean` | No | `false` | Include subgraph events in stream |
| `metadata` | `object` | No | `null` | Request metadata |

### Multitask strategies

| Strategy | Behavior |
|----------|----------|
| `reject` | Reject the new run if one is already active on the thread |
| `interrupt` | Interrupt the active run, then start the new one |
| `rollback` | Cancel the active run, revert to the previous checkpoint, then start the new one |
| `enqueue` | Queue the new run to start after the active one completes |

### Response

Returns the created `Run` object.

```python
from langgraph_sdk import get_client

client = get_client(url="http://localhost:8000")

run = await client.runs.create(
    thread_id="my-thread-id",
    assistant_id="agent",
    input={"messages": [{"type": "human", "content": "Hello"}]},
)

print(run["run_id"])
print(run["status"])  # "pending" or "running"
```

---

## Create and stream

<ParamField path="POST" type="/threads/{thread_id}/runs/stream">
  Create a run and stream its output as Server-Sent Events (SSE).
</ParamField>

### Path parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `thread_id` | `string` | The thread ID |

### Request body

Same as [Create run](#create-run-background).

### Response

Returns a `text/event-stream` SSE response. The response includes `Location` and `Content-Location` headers pointing to the created run.

### Stream modes

| Mode | Description |
|------|-------------|
| `values` | Full state after each node execution |
| `messages-tuple` | LLM token-by-token output as `[message, metadata]` tuples |
| `events` | All LangGraph events (callbacks, tool calls, etc.) |
| `debug` | Verbose debug events with internal graph state |

You can combine multiple modes by passing a list.

### SSE event types

| Event | Description |
|-------|-------------|
| `metadata` | First event. Contains `run_id`. |
| `values` | State snapshot (when using `values` mode) |
| `messages/partial` | Streaming token (when using `messages-tuple` mode) |
| `messages/complete` | Finished message (when using `messages-tuple` mode) |
| `messages/metadata` | Message metadata (when using `messages-tuple` mode) |
| `events` | LangGraph callback event (when using `events` mode) |
| `updates` | Node-level state update |
| `error` | Error during execution |
| `end` | Final event. Stream is complete. |

```python
async for chunk in client.runs.stream(
    thread_id="my-thread-id",
    assistant_id="agent",
    input={"messages": [{"type": "human", "content": "Hello"}]},
    stream_mode=["values", "messages-tuple"],
):
    if chunk.event == "values":
        print("State update:", chunk.data)
    elif chunk.event == "messages/partial":
        print(chunk.data[0]["content"], end="", flush=True)
```

---

## Create and wait

<ParamField path="POST" type="/threads/{thread_id}/runs/wait">
  Create a run, execute it synchronously, and return the final output directly. Times out after 5 minutes.
</ParamField>

### Path parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `thread_id` | `string` | The thread ID |

### Request body

Same as [Create run](#create-run-background).

### Response

Returns the final graph output as a JSON object.

```python
output = await client.runs.wait(
    thread_id="my-thread-id",
    assistant_id="agent",
    input={"messages": [{"type": "human", "content": "Hello"}]},
)

print(output["messages"][-1]["content"])
```

---

## List runs

<ParamField path="GET" type="/threads/{thread_id}/runs">
  List all runs for a thread, newest first.
</ParamField>

### Path parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `thread_id` | `string` | The thread ID |

### Query parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `limit` | `integer` | `10` | Max results (min 1) |
| `offset` | `integer` | `0` | Pagination offset (min 0) |
| `status` | `string` | `null` | Filter by run status |

### Response

Returns `list[Run]`.

```python
runs = await client.runs.list(thread_id="my-thread-id")
for run in runs:
    print(f"{run['run_id']}: {run['status']}")
```

---

## Get run

<ParamField path="GET" type="/threads/{thread_id}/runs/{run_id}">
  Fetch a single run by ID.
</ParamField>

### Path parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `thread_id` | `string` | The thread ID |
| `run_id` | `string` | The run ID |

### Response

Returns a `Run` object.

```python
run = await client.runs.get(
    thread_id="my-thread-id",
    run_id="my-run-id",
)
```

---

## Stream existing run

<ParamField path="GET" type="/threads/{thread_id}/runs/{run_id}/stream">
  Attach to a running run's SSE stream, or get the final event if it already completed. Supports SSE reconnection via `Last-Event-ID` header.
</ParamField>

### Path parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `thread_id` | `string` | The thread ID |
| `run_id` | `string` | The run ID |

### Headers

| Header | Description |
|--------|-------------|
| `Last-Event-ID` | Resume from a specific event for reconnection |

### Response

Returns a `text/event-stream` SSE response.

```python
async for chunk in client.runs.stream(
    thread_id="my-thread-id",
    run_id="my-run-id",
):
    print(chunk)
```

---

## Join run

<ParamField path="GET" type="/threads/{thread_id}/runs/{run_id}/join">
  Wait for a run to complete (up to 30 seconds) and return its final output.
</ParamField>

### Path parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `thread_id` | `string` | The thread ID |
| `run_id` | `string` | The run ID |

### Response

Returns the final graph output as a JSON object.

```python
output = await client.runs.join(
    thread_id="my-thread-id",
    run_id="my-run-id",
)
```

---

## Cancel run

<ParamField path="POST" type="/threads/{thread_id}/runs/{run_id}/cancel">
  Cancel or interrupt a running run.
</ParamField>

### Path parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `thread_id` | `string` | The thread ID |
| `run_id` | `string` | The run ID |

### Query parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `wait` | `integer` | `0` | `1` to wait for the task to settle |
| `action` | `string` | `"cancel"` | `"cancel"` for hard stop, `"interrupt"` for cooperative interrupt |

### Response

Returns the updated `Run` object.

```python
# Hard cancel
await client.runs.cancel(
    thread_id="my-thread-id",
    run_id="my-run-id",
)

# Cooperative interrupt
await client.runs.cancel(
    thread_id="my-thread-id",
    run_id="my-run-id",
    action="interrupt",
    wait=1,
)
```

---

## Update run

<ParamField path="PATCH" type="/threads/{thread_id}/runs/{run_id}">
  Update a run's status.
</ParamField>

### Path parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `thread_id` | `string` | The thread ID |
| `run_id` | `string` | The run ID |

### Request body

| Field | Type | Description |
|-------|------|-------------|
| `run_id` | `string` | Run to update |
| `status` | `string` | New status |
| `message` | `string` | Optional message |

### Response

Returns the updated `Run` object.

---

## Delete run

<ParamField path="DELETE" type="/threads/{thread_id}/runs/{run_id}">
  Delete a run record. Returns `409` if the run is active unless `force=1`.
</ParamField>

### Path parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `thread_id` | `string` | The thread ID |
| `run_id` | `string` | The run ID |

### Query parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `force` | `integer` | `0` | `1` to cancel the run before deleting |

### Response

Returns `204 No Content`.

---

## Run object

The `Run` object returned by all run endpoints:

| Field | Type | Description |
|-------|------|-------------|
| `run_id` | `string` | Unique run identifier |
| `thread_id` | `string` | Parent thread ID |
| `assistant_id` | `string` | Assistant that was executed |
| `status` | `string` | Run status (see below) |
| `input` | `object` | Input that was provided |
| `output` | `object \| null` | Final graph output (populated on completion) |
| `error_message` | `string \| null` | Error detail (populated on failure) |
| `config` | `object \| null` | Effective config |
| `context` | `object \| null` | Effective context |
| `user_id` | `string` | Owner identity |
| `created_at` | `datetime` | Creation timestamp |
| `updated_at` | `datetime` | Last update timestamp |

### Run statuses

| Status | Description |
|--------|-------------|
| `pending` | Run is queued but not yet started |
| `running` | Run is currently executing |
| `success` | Run completed successfully |
| `error` | Run failed with an error |
| `timeout` | Run exceeded the time limit |
| `interrupted` | Run was interrupted (HITL or cancel) |
